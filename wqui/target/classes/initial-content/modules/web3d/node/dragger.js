/** *  This file is part of the spp(Superpolo Platform). *  Copyright (C) by SanPolo Co.Ltd. *  All rights reserved. * *  See http://www.spolo.org/ for more information. * *  SanPolo Co.Ltd *  http://www.spolo.org/ *  Any copyright issues, please contact: copr@spolo.org**///dragger实现了对模型的平移、旋转和缩放的操作.define("web3d/node/dragger",["dojo/topic","dojo/_base/lang"],	function(topic,lang){		var _lockState = 0; //0 unlock,1 lock to x ,2 lock to y.		var modelManageType = 2; //初始化时为拖动操作		var x3d = document.getElementById("_sp_x3d_main_tag");//XXX 需要获得runtime对象获取变换矩阵与对摄像机控制		return dojo.declare([],{			//传入了Transform对象。			constructor : function(trans){							this.Transform = trans;				//添加辅助坐标轴以及其事件关联				topic.publish("axisHelper/add", this.Transform);				var dragObj = this;								var _lastMouseX = 0;				var _lastMouseY = 0;								//FIXME: 这里简单使用几个快捷键来更新lockstate.是否应该扔到二维UI中?				topic.subscribe("system/onKeyPress_x",function(){					_lockState = 1;				});				topic.subscribe("system/onKeyPress_y",function(){					_lockState = 2;				});				topic.subscribe("system/onKeyPress_u",function(){					_lockState = 0;				});												//订阅模型选择消息				topic.subscribe("toolbar/model/select",function(){					modelManageType = 1;				});				//订阅模型平移消息				topic.subscribe("toolbar/model/translate",function(){					modelManageType = 2;				});				//订阅模型旋转消息				topic.subscribe("toolbar/model/rotate",function(){					modelManageType = 3;				});				//订阅模型缩放消息				topic.subscribe("toolbar/model/scale",function(){					modelManageType = 4;				});				//订阅模型删除消息				topic.subscribe("toolbar/model/delete",function(){					//modelManageType = 5;					if(Spolo.modelSelectable) {						topic.publish("tree/remove", Spolo.selectedObj);					}				});								//when mouse pressed, register ondrag and on mouse release events				this.MousePressHandler = topic.subscribe("system/onMousePress",function(x,y,buttonState) {					//viewarea obj					var viewarea = Spolo.viewarea;					//current action mode					var cm = Spolo.currentAction;					var _lastMouseX = x;					var _lastMouseY = y;					// 当鼠标按下记录鼠标在屏幕上的位置					//the point where the mouse hit the obj					dragObj.pickpos = x3dom.fields.SFVec3f.copy(viewarea._pickingInfo.pickPos);					//the offset from the hit point to the centre of the mesh					dragObj.offset = trans._vf.translation.subtract(dragObj.pickpos);										//记录此时屏幕坐标系下鼠标与模型中心的距离					var _trans_center = viewarea.projectVector(trans.getCurrentTransform().multMatrixPnt(new x3dom.fields.SFVec3f(0,0,0)));					var _trans_sceen_x = (_trans_center.x+1)*viewarea._width / 2;					var _trans_sceen_y =-(_trans_center.y-1)*viewarea._height / 2;					var _last_dx = x - _trans_sceen_x;					var _last_dy = y - _trans_sceen_y;					var _lastLength = Math.sqrt(_last_dx*_last_dx + _last_dy*_last_dy);					//determine if the mouse is grabbing anything					var hitobj = viewarea._pickingInfo.pickObj;					if(Spolo.cameraLock) //if the mesh lock key is pressed						return;											if(!hitobj) //if nothing grabbed, we do nothing						return;											//模型被选中时执行模型操作					var installDragHandler = true;										//当开始对模型操作时，拦截onDrag方法为自定义的对模型操作					Spolo.eventProcessor.onDrag = true;					this.MouseDragHandler = topic.subscribe("system/onDrag",function(x,y,buttonState){						//只有在模型操作下和当前模型解锁情况下允许拖动						if(Spolo.modelSelectable && !trans.isLocked()) {							x3d.runtime.noNav();							var  leftButttonHandler;							var  middleButtonHandler;							var  rightButtonHandler;							//旋转方法							function Rotate() {								var rotX = ((x - _lastMouseX)/ viewarea._width) * 2*Math.PI;								var rotY = ((y - _lastMouseY)/viewarea._height) * 2*Math.PI;																var axis = new x3dom.fields.SFVec3f(0,0,-1);								var cctowc = x3d.runtime.getCameraToWorldCoordinatesMatrix();								axis = cctowc.multMatrixVec(axis);								axis = trans.getCurrentTransform().inverse().multMatrixVec(axis);								trans.localRotate(axis,rotX-rotY);																_lastMouseX = x;								_lastMouseY = y;									//LocalRotate比较自然。相对于worldRotate.									//@FIXME: worldRotate计算有误？								/*									switch(_lockState)									{									case 0:										trans.localRotate(upDir,rotX);										trans.localRotate(rightDir, - rotY);										break;																			case 1:	//lock x.										trans.localRotate(upDir,rotY);										break;																			case 2:	//lock y.										trans.localRotate(rightDir,rotX);										break;									}									_lastMouseX = x;									_lastMouseY = y;									break;																*/							}							//缩放方法							function Scale() {//FIXME 当前的缩放方法仅仅是实现了简单的拖动模型放大和缩小，没有考虑拖动速度的计算								// var scaX = x - _lastMouseX;								// var scaY = y - _lastMouseY;								// var d = scaX - scaY;								// if(  d > 0 ) {									// trans._vf.scale = trans._vf.scale.multiply(1.01);								// } else if( d < 0 ) {									// trans._vf.scale = trans._vf.scale.multiply(0.99);								// }								// trans.scale(trans._vf.scale);								// console.log("trans.scale "+trans._vf.scale);																// _lastMouseX = x;								// _lastMouseY = y;								var dx = x - _trans_sceen_x;								var dy = y - _trans_sceen_y;								var curr_length = Math.sqrt(dx*dx + dy*dy);								var rate = curr_length / _lastLength;																trans._vf.scale = trans._vf.scale.multiply(rate);																trans.scale(trans._vf.scale);																_lastLength = curr_length;							}							//平移方法							function Translate() {								if(Spolo.current_trans == Spolo.transList[0]) {									//console.log("平移");									// var pos = trans._vf.translation;									// var pos = viewarea._pickingInfo.pickPos;									var pos = dragObj.pickpos;																		var _intersect_pos_inCC = viewarea.projectVector( pos );									var _Mouse3D = new x3dom.fields.SFVec3f( (x / viewarea._width) * 2 - 1,																				-(y / viewarea._height) * 2 + 1,																				_intersect_pos_inCC.z);																				//先把坐标系换算为世界坐标系。									var pos_WC = viewarea.unprojectVector(_Mouse3D); 									//记录下鼠标当前三维空间点的z点									var tem = x3dom.fields.SFVec3f.copy(pos_WC);																		//减去模型中心点和鼠标点击位置的偏差									pos_WC = pos_WC.add(dragObj.offset);									//change to LC 									trans.moveTo_WC(pos_WC);								} else {									topic.punlish("assAxis/answer");								}							}																					switch(modelManageType) {								case 1 : //选择									//发布给2D页面模型高亮消息									topic.publish("model/light", Spolo.selectedObj);									//选择时不允许拖动模型									installDragHandler = false;									break;								case 2 : //平移									//获取平移方法句柄									leftButttonHandler = Translate;									break;								case 3 : //旋转									//获取旋转方法句柄									leftButttonHandler = Rotate;									break;								case 4 : //缩放									//获取缩放方法句柄									leftButttonHandler = Scale;									break;								default:									installDragHandler = false;									break;							}							//鼠标右键默认操作							rightButtonHandler = Rotate;							//鼠标中键默认操作							middleButtonHandler= Scale;							if(installDragHandler) {								switch(buttonState) {									case 1 : //鼠标左键操作										leftButttonHandler.call(this);										break;									case 2 : //鼠标右键操作										rightButtonHandler.call(this);										break;									case 4 : //鼠标中键操作										//摄像机在非自由模式强行改buttonState为4，这里需要自适应，通过全局变量判断										if(Spolo.current_view == Spolo.view_list[0]) {											middleButtonHandler.call(this);										} else {											leftButttonHandler.call(this);										}										break;								}							}						}					});					this.MouseReleaseHandler = topic.subscribe("system/onMouseRelease",function(x,y,buttonState){						//注销事件。						if(this.MouseReleaseHandler)							this.MouseReleaseHandler.remove();						if(this.MouseDragHandler)							this.MouseDragHandler.remove();						//TODO: 通知全局对象。						Spolo.eventProcessor.onDrag = false;						//reset						x3d.runtime.examine();						dragObj.centre_pnt = null;					});				}),							//added for axis helper, used to choose among all the 				//make it adaptable to its parameters								this.setActionMode = function(i) {					if((!isNaN(i)) && (i < 3)) //if i is a number					{						Spolo.currentAction = Spolo.actionModeList[i];					}else{ //or it is a string						for(var a = 0; a < Spolo.actionModeList.length; a++) {							if(i == Spolo.actionModeList[a]) {								Spolo.currentAction = i;							}						}					}					//if nothing mathes, it is an error				},								//删除消息关注。				// x3dom.nodeTypes.Transform.prototype.				this.unload = function() {					var tthis = this.Transform;										if(this.MouseReleaseHandler)						this.MouseReleaseHandler.remove();					if(this.MouseDragHandler)						this.MouseDragHandler.remove();					if(this.MousePressHandler)						this.MousePressHandler.remove();										if(tthis._sp_selectedobj) {						// delete tthis._sp_selectedobj._xmlNode["onclick"]; 						delete tthis._sp_selectedobj._xmlNode["onmousedown"]; 						// delete tthis._sp_selectedobj._xmlNode["onmouseover"]; 						// delete tthis._sp_selectedobj._xmlNode["onmouseout"]; 						// delete tthis._sp_selectedobj._xmlNode["onmousemove"]; 						delete tthis._sp_selectedobj._xmlNode["onmouseup"];  					}				}			}		});});