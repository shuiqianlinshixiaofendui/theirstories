/** *  This file is part of the spp(Superpolo Platform). *  Copyright (C) by SanPolo Co.Ltd. *  All rights reserved. * *  See http://www.spolo.org/ for more information. * *  SanPolo Co.Ltd *  http://www.spolo.org/ *  Any copyright issues, please contact: copr@spolo.org**//**	摄像机子模块	负责处理绕物体模式下摄像机事件：	* 摄像机旋转	* 摄像机缩放*/define("web3d/operate/operate_aroundObjView",["dojo/topic"],function(topic){	// 摄像机当前操作	var cameraState = 0;		var CAMERA_DEFAULT = 0;	var CAMERA_ROTATE = 1;	var CAMERA_SCALE = 2;		var viewarea;	var disvec ;		//控制鼠标第一次按下时不执行操作	var initBool = false;			//固定视角绕物体模式旋转	var rotate = function(dx,dy){		var alpha = (dy * 2 * Math.PI) / viewarea._width;		var beta = (dx * 2 * Math.PI) / viewarea._height;		var gama = Math.sqrt(alpha*alpha)>Math.sqrt(beta*beta) ? alpha : beta;		var mat = viewarea.getViewMatrix();		var mz = x3dom.fields.SFMatrix4f.rotationZ(gama);		// var my = x3dom.fields.SFMatrix4f.rotationY(beta);		var center = Spolo.selectedObj._trafo.e3();		mat.setTranslate(new x3dom.fields.SFVec3f(0,0,0));		viewarea._rotMat = viewarea._rotMat.			mult(x3dom.fields.SFMatrix4f.translation(center)).			mult(mat.inverse()).			mult(mz.inverse()).			mult(mat).			mult(x3dom.fields.SFMatrix4f.translation(center.negate()));	}		//自由视角绕物体模式旋转	var rotate2 = function(dx,dy){		var alpha = (dy * 2 * Math.PI) / viewarea._width;		var beta = (dx * 2 * Math.PI) / viewarea._height;		var mat = viewarea.getViewMatrix();		var mx = x3dom.fields.SFMatrix4f.rotationX(alpha);		var my = x3dom.fields.SFMatrix4f.rotationY(beta);		var center = Spolo.selectedObj._trafo.e3();		mat.setTranslate(new x3dom.fields.SFVec3f(0,0,0));		viewarea._rotMat = viewarea._rotMat.			mult(x3dom.fields.SFMatrix4f.translation(center)).			mult(mat.inverse()).			mult(mx).mult(my).			mult(mat).			mult(x3dom.fields.SFMatrix4f.translation(center.negate()));	}		//固定视角绕物体模式缩放	var scale = function(dx,dy,min,max,ok,d,vec,viewpoint){		if (viewarea._scene._lastMin && viewarea._scene._lastMax)		{			d = (viewarea._scene._lastMax.subtract(viewarea._scene._lastMin)).length();			d = (d < x3dom.fields.Eps) ? 1 : d;		}		else		{			min = x3dom.fields.SFVec3f.MAX();			max = x3dom.fields.SFVec3f.MIN();			ok = viewarea._scene.getVolume(min, max, true);			if (ok) {				viewarea._scene._lastMin = min;				viewarea._scene._lastMax = max;			}			d = ok ? (max.subtract(min)).length() : 10;			d = (d < x3dom.fields.Eps) ? 1 : d;		}		var normal = d*(dx+dy)/viewarea._height;		vec = new x3dom.fields.SFVec3f(disvec.x*(normal/disvec.z) , disvec.y*(normal/disvec.z) , normal);		viewarea._movement = viewarea._movement.add(vec);		viewarea._transMat = viewpoint.getViewMatrix().inverse().			mult(x3dom.fields.SFMatrix4f.translation(viewarea._movement)).			mult(viewpoint.getViewMatrix());	}		// 自定义ondrag	var myOnDrag1 = function (x, y, buttonState){		myOnDrag1 = function(x,y,buttonState){				viewarea.handleMoveEvt(x, y, buttonState);				var navi = viewarea._scene.getNavigationInfo();				if (navi._vf.type[0].length <= 1 || navi._vf.type[0].toLowerCase() === "none") {					return;				}				var dx = x - viewarea._lastX;				var dy = y - viewarea._lastY;				var min, max, ok, d, vec;				var viewpoint = viewarea._scene.getViewpoint();				if (navi._vf.type[0].toLowerCase() === "examine")				{					if (buttonState & 1 )//left					{						if(cameraState == CAMERA_DEFAULT){							if(Spolo.current_view != Spolo.view_list[0]){								rotate(dx,dy);							}else{								rotate2(dx,dy);							}						}else if(cameraState == CAMERA_ROTATE){							if(Spolo.current_view != Spolo.view_list[0]){								rotate(dx,dy);							}else{								rotate2(dx,dy);							}						}else if(cameraState == CAMERA_SCALE){							scale(dx,dy,min,max,ok,d,vec,viewpoint);						}					}										if (event.button == 2)					{						if(Spolo.current_view != Spolo.view_list[0]){							rotate(dx,dy);						}else{							rotate2(dx,dy);						}					}									if (buttonState & 2 && event.button !=2)					{						scale(dx,dy,min,max,ok,d,vec,viewpoint);					}														}				viewarea._dx = dx;				viewarea._dy = dy;				viewarea._lastX = x;				viewarea._lastY = y;			}				};		// 初始化红心	function initCap(){		var sync = Spolo.dataSync;		var data = sync.get_camera_data();		var cap = data.cameraAssisPoint;		var position = Spolo.selectedObj._trafo.e3();		cap.receivePos(new x3dom.fields.SFVec3f(position.x,position.y,position.z));	}		var operate_aroundObjView = dojo.declare([],{		constructor : function(x3d){			initCap();			viewarea = x3d.runtime.canvas.doc._viewarea;			this.aroundObj_onDragHandle = topic.subscribe("system/onDrag", function(x, y, buttonState){				if(Spolo.OperationMode == 1){					myOnDrag1(x, y, buttonState);				}			});						this.PressHandle = topic.subscribe("system/onMousePress",function(x,y,buttonState){				if(Spolo.OperationMode == 1){					if( viewarea._lastX == -1 || viewarea._lastY == -1){						viewarea._lastX = x;						viewarea._lastY = y;						initBool = true;					}else{						initBool = true;					}										if(Spolo.selectedObj){						var viewmatrix = viewarea.getViewMatrix();						disvec =  viewmatrix.mult(Spolo.selectedObj._trafo).e3();					}				}			});						this.ReleaseHandle = topic.subscribe("system/onMouseRelease",function(x,y,buttonState){				if(Spolo.OperationMode == 1){					viewarea._lastX = -1;					viewarea._lastY = -1;				}			});		},				// 响应摄像机旋转操作		aroundObjRotate : function(){			cameraState = CAMERA_ROTATE;		},				// 响应摄像机缩放操作		aroundObjScale : function(){			cameraState = CAMERA_SCALE;		},				// 删除node		unload : function (){			if(this.aroundObj_onDragHandle){				this.aroundObj_onDragHandle.remove();			}			if(this.PressHandle){				this.PressHandle.remove();			}			if(this.ReleaseHandle){				this.ReleaseHandle.remove();			}		}	});		return operate_aroundObjView;});