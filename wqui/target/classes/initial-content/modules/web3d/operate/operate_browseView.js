/** *  This file is part of the spp(Superpolo Platform). *  Copyright (C) by SanPolo Co.Ltd. *  All rights reserved. * *  See http://www.spolo.org/ for more information. * *  SanPolo Co.Ltd *  http://www.spolo.org/ *  Any copyright issues, please contact: copr@spolo.org**//**	摄像机子模块	负责处理固定视角下摄像机事件：	* 摄像机平移	* 摄像机旋转	* 摄像机缩放*/define("web3d/operate/operate_browseView",["dojo/topic"],function(topic){	var cameraState = 0;	var CAMERA_FREE = 0;	var CAMERA_MOVE = 1; 	var CAMERA_ROTATE = 2; 	var CAMERA_SCALE = 3;		var viewarea;		//控制鼠标第一次按下时不执行操作	var initBool = false;		//平移操作	var move = function(dx,dy,min,max,ok,d,vec,viewpoint){			if (viewarea._scene._lastMin && viewarea._scene._lastMax)			{				d = (viewarea._scene._lastMax.subtract(viewarea._scene._lastMin)).length();				d = (d < x3dom.fields.Eps) ? 1 : d;			}			else			{				min = x3dom.fields.SFVec3f.MAX();				max = x3dom.fields.SFVec3f.MIN();				ok = viewarea._scene.getVolume(min, max, true);				if (ok) {					viewarea._scene._lastMin = min;					viewarea._scene._lastMax = max;				}				d = ok ? (max.subtract(min)).length() : 10;				d = (d < x3dom.fields.Eps) ? 1 : d;			}			vec = new x3dom.fields.SFVec3f(d*dx/(viewarea._width), d*(-dy)/(viewarea._height), 0);			viewarea._movement = viewarea._movement.add(vec);			viewarea._transMat = viewpoint.getViewMatrix().inverse().				mult(x3dom.fields.SFMatrix4f.translation(viewarea._movement)).				mult(viewpoint.getViewMatrix());	}		//旋转操作	var rotate = function(dx,dy,min,max,ok,d,vec,viewpoint){		var alpha = (dy * 2 * Math.PI) / viewarea._width;		var beta = (dx * 2 * Math.PI) / viewarea._height;		var mat = viewarea.getViewMatrix();		var mx = x3dom.fields.SFMatrix4f.rotationX(alpha);		var my = x3dom.fields.SFMatrix4f.rotationY(beta);				var viewmatrix = viewarea.getViewMatrix();		var center = x3dom.fields.SFMatrix4f.translation(new x3dom.fields.SFVec3f(0,0,0)).mult(viewmatrix.inverse()).e3();		mat.setTranslate(new x3dom.fields.SFVec3f(0,0,0));							viewarea._rotMat = viewarea._rotMat		.mult(x3dom.fields.SFMatrix4f.translation(center))		.mult(mat.inverse())		.mult(mx)		.mult(mat)		.mult(x3dom.fields.SFMatrix4f.translation(center.negate()))				.mult(x3dom.fields.SFMatrix4f.translation(center))				.mult(my)				.mult(x3dom.fields.SFMatrix4f.translation(center.negate()))	}		//缩放操作	var scale = function(dx,dy,min,max,ok,d,vec,viewpoint){		viewpoint.postMessage("fieldOfView", viewpoint._vf.fieldOfView + -dy/12*0.05); 	 	viewpoint.fieldChanged("fieldOfView"); 	}		// 自定义ondrag	var myOnDrag = function (x, y, buttonState){		if(initBool==true){			// should onmouseover/-out be handled on drag?			viewarea.handleMoveEvt(x, y, buttonState);			var dx = x - viewarea._lastX;			var dy = y - viewarea._lastY;			var min, max, ok, d, vec;			var viewpoint = viewarea._scene.getViewpoint();			if (buttonState & 1 && Spolo.OperationMode == 1 && !event.shiftKey)			{				if(cameraState == CAMERA_FREE){					move(dx,dy,min,max,ok,d,vec,viewpoint);				}else if(cameraState == CAMERA_MOVE){					move(dx,dy,min,max,ok,d,vec,viewpoint);				}else if(cameraState == CAMERA_ROTATE){					rotate(dx,dy,min,max,ok,d,vec,viewpoint);				}else if(cameraState == CAMERA_SCALE){					scale(dx,dy,min,max,ok,d,vec,viewpoint);				}			}					if (buttonState & 2 && event.button ==0)			{				scale(dx,dy,min,max,ok,d,vec,viewpoint);			}				if (buttonState & 4 && !event.shiftKey)			{				rotate(dx,dy,min,max,ok,d,vec,viewpoint);			}			if (event.button ==1 && event.shiftKey)			{				move(dx,dy,min,max,ok,d,vec,viewpoint);			}			viewarea._dx = dx;			viewarea._dy = dy;			viewarea._lastX = x;			viewarea._lastY = y;		}				};		// 初始化红心	function initCap(){		var sync = Spolo.dataSync;		var data = sync.get_camera_data();		var cap = data.cameraAssisPoint;		cap.receivePos(new x3dom.fields.SFVec3f(0,0,0));	}		var operate_browseView = dojo.declare([],{		constructor : function(x3d){			initCap();			viewarea = x3d.runtime.canvas.doc._viewarea;			this.browseView_onDragHandle = topic.subscribe("system/onDrag", function(x, y, buttonState){				if(Spolo.OperationMode == 1){					myOnDrag(x, y, buttonState);				}			});						this.PressHandle = topic.subscribe("system/onMousePress",function(x,y,buttonState){				if(Spolo.OperationMode == 1){					if( viewarea._lastX == -1 || viewarea._lastY == -1){						viewarea._lastX = x;						viewarea._lastY = y;						initBool = true;					}else{						initBool = true;					}				}			});						this.ReleaseHandle = topic.subscribe("system/onMouseRelease",function(x,y,buttonState){				if(Spolo.OperationMode == 1){					viewarea._lastX = -1;					viewarea._lastY = -1;				}			});		},				// 响应摄像机平移操作		browseViewTranslate : function(){			cameraState = CAMERA_MOVE;		},				// 响应摄像机旋转操作		browseViewRotate : function(){			cameraState = CAMERA_ROTATE;		},				// 响应摄像机缩放操作		browseViewScale : function(){			cameraState = CAMERA_SCALE;		},				// 响应摄像机重置操作		browseViewReset : function(){			// 当reset按钮点击后，将对摄像机所有操作都清空			var viewpoint = viewarea._scene.getViewpoint();			dx = 0 ;			dy = 0 ;			viewpoint.postMessage("fieldOfView", 0.785398); 			viewpoint.fieldChanged("fieldOfView"); 			// 并且将摄像机设置到初始位置			if(viewarea){						viewarea.resetView();			} 		},				// 删除node		unload : function (){			if(this.browseView_onDragHandle){				this.browseView_onDragHandle.remove();			}			if(this.PressHandle){				this.PressHandle.remove();			}			if(this.ReleaseHandle){				this.ReleaseHandle.remove();			}		}	});		return operate_browseView;});