/** *  This file is part of the spp(Superpolo Platform). *  Copyright (C) by SanPolo Co.Ltd. *  All rights reserved. * *  See http://www.spolo.org/ for more information. * *  SanPolo Co.Ltd *  http://www.spolo.org/ *  Any copyright issues, please contact: copr@spolo.org**//**	摄像机子模块	负责处理摄像机事件：	* 摄像机平移	* 摄像机旋转	* 摄像机缩放*/define("web3d/operate/operate_freeView",["dojo/topic"],function(topic){		// 摄像机锁定	var camera_isLocked = false;	// 摄像机动作	var camera_status = 0 ;	var CAMERA_MOVE = 0; 	var CAMERA_ROTATE = 1; 	var CAMERA_SCALE = 2; 			/**		全局变量x3domViewarea,dx,dy,viewpoint,min, max, ok, d, vec	*/ 	var x3domViewarea = null ;	var dx = 0 ;	var dy = 0 ;	var viewpoint = null ;	var min, max, ok, d, vec;			/**		处理camera_move		autoCreate : copy x3dom 源代码	*/		function cameraMove(){				// 获取移动前红心在摄像机坐标系下的位置		var sync = Spolo.dataSync;		var data = sync.get_camera_data();		var cap = data.cameraAssisPoint;		var capPosition_world = cap.getPosition();		var viewmatrix = x3domViewarea.getViewMatrix();		var capPosition_view = x3dom.fields.SFMatrix4f.translation(capPosition_world).mult(viewmatrix);			if (x3domViewarea._scene._lastMin && x3domViewarea._scene._lastMax)		{			d = (x3domViewarea._scene._lastMax.subtract(x3domViewarea._scene._lastMin)).length();			d = (d < x3dom.fields.Eps) ? 1 : d;		}		else		{			min = x3dom.fields.SFVec3f.MAX();			max = x3dom.fields.SFVec3f.MIN();			ok = x3domViewarea._scene.getVolume(min, max, true);			if (ok) {				x3domViewarea._scene._lastMin = min;				x3domViewarea._scene._lastMax = max;			}			d = ok ? (max.subtract(min)).length() : 10;			d = (d < x3dom.fields.Eps) ? 1 : d;		}		vec = new x3dom.fields.SFVec3f(d*dx/x3domViewarea._width, d*(-dy)/x3domViewarea._height, 0);		x3domViewarea._movement = x3domViewarea._movement.add(vec);		//TODO; move real distance along viewing plane		x3domViewarea._transMat = viewpoint.getViewMatrix().inverse().		mult(x3dom.fields.SFMatrix4f.translation(x3domViewarea._movement)).		mult(viewpoint.getViewMatrix());				// 移动后将红心位置改变		var viewmatrix2 = x3domViewarea.getViewMatrix();		capPosition_view_new = new x3dom.fields.SFVec3f(0,0,capPosition_view._23);		capPosition_world_new = viewmatrix2.inverse().mult(x3dom.fields.SFMatrix4f.translation(capPosition_view_new)).e3();		cap.receivePos(capPosition_world_new);	}			/**		处理camera_rotate,参考帖子号#918	*/	function cameraRotate(){				var alpha = (dy * 2 * Math.PI) / x3domViewarea._width;		var beta = (dx * 2 * Math.PI) / x3domViewarea._height;		var mat = x3domViewarea.getViewMatrix();		var mx = x3dom.fields.SFMatrix4f.rotationX(alpha);		var my = x3dom.fields.SFMatrix4f.rotationY(beta);		// 获取红心位置		var sync = Spolo.dataSync;		var data = sync.get_camera_data();		var cap = data.cameraAssisPoint;		var center = cap.getPosition();		mat.setTranslate(new x3dom.fields.SFVec3f(0,0,0));				x3domViewarea._rotMat = x3domViewarea._rotMat			.mult(x3dom.fields.SFMatrix4f.translation(center))			.mult(mat.inverse())			.mult(mx)			.mult(mat)			.mult(x3dom.fields.SFMatrix4f.translation(center.negate()))						.mult(x3dom.fields.SFMatrix4f.translation(center))					.mult(my)					.mult(x3dom.fields.SFMatrix4f.translation(center.negate()))							}	/**		处理camera_scale		autoCreate : copy x3dom 源代码	*/	function cameraScale(){				// 获取红心位置		var sync = Spolo.dataSync;		var data = sync.get_camera_data();		var cap = data.cameraAssisPoint;		var capPosition = cap.getPosition();				// 获取摄像机位置		var viewmatrix = x3domViewarea.getViewMatrix();		var cameraPosition = x3dom.fields.SFMatrix4f.translation(new x3dom.fields.SFVec3f(0,0,0)).mult(viewmatrix.inverse()).e3();				var distance = cameraPosition.subtract(capPosition);					if (x3domViewarea._scene._lastMin && x3domViewarea._scene._lastMax)		{			d = (x3domViewarea._scene._lastMax.subtract(x3domViewarea._scene._lastMin)).length();			d = (d < x3dom.fields.Eps) ? 1 : d;		}		else		{			min = x3dom.fields.SFVec3f.MAX();			max = x3dom.fields.SFVec3f.MIN();			ok = x3domViewarea._scene.getVolume(min, max, true);			if (ok) {				x3domViewarea._scene._lastMin = min;				x3domViewarea._scene._lastMax = max;			}			d = ok ? (max.subtract(min)).length() : 10;			d = (d < x3dom.fields.Eps) ? 1 : d;		}		vec = new x3dom.fields.SFVec3f(0, 0, d*(dx+dy)/x3domViewarea._height);				if( distance.length()-vec.z <=0.5){			if(vec.z <0){						}else{				return;			}		}				x3domViewarea._movement = x3domViewarea._movement.add(vec);				//TODO; move real distance along viewing ray		x3domViewarea._transMat = viewpoint.getViewMatrix().inverse().		mult(x3dom.fields.SFMatrix4f.translation(x3domViewarea._movement)).		mult(viewpoint.getViewMatrix());					}			/**		当用户点击了reset按钮后，		* 清空摄像机操作中所有变量		* 并且将摄像机设置到初始位置	*/	function resetCameraOperate(){					dx = 0 ;		dy = 0 ;		if(viewpoint){			viewpoint.postMessage("fieldOfView", 0.785398); 			viewpoint.fieldChanged("fieldOfView"); 		}		        var sync = Spolo.dataSync;		var data = sync.get_camera_data();		var cap = data.cameraAssisPoint;        cap.receivePos(new x3dom.fields.SFVec3f(0,0,0));        data.last_matrix = x3dom.fields.SFMatrix4f.identity();        sync.update_camera_data(data);				if(x3domViewarea){					x3domViewarea.resetView();		} 				Spolo.aroundObjOperationMode = false ;			}		// ------------------------------------------------------------------------------			var operate_freeView = dojo.declare([],{			constructor : function(x3d){			// 为使firefox兼容event而设置			var shift = false;			var keyboard = {				keydown : function ( event ){					if(event.shiftKey){						shift = true;					}else{						shift = false;					}				},				keyup : function ( event ){					shift = false;				}			}			document.addEventListener("keydown", keyboard.keydown, false);			document.addEventListener("keyup", keyboard.keyup, false);						// 引入基础node，cameraAssisPoint node 提供摄像机lookat点			var sync = Spolo.dataSync;			var data = sync.get_camera_data();			var cap = data.cameraAssisPoint;			x3domViewarea = x3d.runtime.canvas.doc._viewarea;			// cap.receivePos(new x3dom.fields.SFVec3f(0,0,0));			// 响应鼠标抬起，当鼠标抬起后，将x3domViewarea._lastX，x3domViewarea._lastY至-1，所有操作从新开始			this.mrs_ReleaseHandle = topic.subscribe("system/onMouseRelease",function(x,y,buttonState){				if(x3domViewarea && Spolo.OperationMode == 1){					x3domViewarea._lastX = -1;					x3domViewarea._lastY = -1;				}			});					this.mrs_onDragHandle = topic.subscribe("system/onDrag",function(x,y,buttonState){				                // 如果 cap node 存在，将摄像机lookat点传给node				// if(Spolo.OperationMode == 1){					// if(cap){						// cap.receivePos(tpAxis);					// }								if(Spolo.dataSync){						var camera_json = Spolo.dataSync.get_camera_data();						camera_isLocked = camera_json.camera_locked;					}									if(!camera_isLocked){					 						/**							当前只兼容鼠标左键操作							包括平移，旋转，缩放都是通过鼠标左键与二维按钮配合实现						*/																/** 								本方法，参考x3dom.Viewarea.onDrag方法中的旋转操作								在本操作中，没有x3domViewarea,需要将x3domViewarea替换成x3d.runtime.canvas.doc._viewarea							*/																					x3domViewarea.handleMoveEvt(x, y, buttonState);													var navi = x3domViewarea._scene.getNavigationInfo();							//console.log(navi);							// if (navi._vf.type[0].length <= 1 || navi._vf.type[0].toLowerCase() === "none") {								// return;							// }							// 当第一次操作时，x3domViewarea._lastX和x3domViewarea._lastY是-1，所以第一次操作需要缓冲一下，第二次onDrag时才开始正式的操作							if( x3domViewarea._lastX == -1 || x3domViewarea._lastY == -1){								x3domViewarea._lastX = x;								x3domViewarea._lastY = y;							}else{								dx = x - x3domViewarea._lastX;								dy = y - x3domViewarea._lastY;																viewpoint = x3domViewarea._scene.getViewpoint();                                if(buttonState & 4 && !shift){									cameraRotate();                                    x3domViewarea._dx = dx;                                    x3domViewarea._dy = dy;                                    x3domViewarea._lastX = x;                                    x3domViewarea._lastY = y;                                }                                if (buttonState & 2 ){								   cameraScale();                                   x3domViewarea._dx = dx;                                    x3domViewarea._dy = dy;                                    x3domViewarea._lastX = x;                                    x3domViewarea._lastY = y;                                }								if (buttonState & 1 && shift){									cameraMove();                                    x3domViewarea._dx = dx;                                    x3domViewarea._dy = dy;                                    x3domViewarea._lastX = x;                                    x3domViewarea._lastY = y;                                }                                if(buttonState & 1 && Spolo.OperationMode == 1 && !shift){                                    switch (camera_status){                                        case CAMERA_MOVE :												cameraMove() ;                                            break ;                                        case CAMERA_ROTATE :  											 cameraRotate();                                            break ;                                        case CAMERA_SCALE :											cameraScale();                                            break ;                                    }                                 x3domViewarea._dx = dx;								x3domViewarea._dy = dy;								x3domViewarea._lastX = x;								x3domViewarea._lastY = y;                                                                    }							}												                                                												}				// }			});		},						// 响应摄像机平移操作		camera_move : function(){			if(camera_status != 0){				camera_status = CAMERA_MOVE;			}		},						// 响应摄像机旋转操作		camera_rotate : function(){			if(camera_status != 1){				camera_status = CAMERA_ROTATE;			}		},				// 响应摄像机缩放操作		camera_scale : function(){			if(camera_status != 2){				camera_status = CAMERA_SCALE;			}		},						// 响应摄像机重置操作		camera_reset : function(){			resetCameraOperate();		},				unload : function (){			if(this.mrs_ReleaseHandle){				this.mrs_ReleaseHandle.remove();			}			if(this.mrs_onDragHandle){				this.mrs_onDragHandle.remove();			}		}	});		return operate_freeView;});