<%
/* 
 *  This file is part of the SPP(Superpolo Platform).
 *  Copyright (C) by SanPolo Co.Ltd.
 *  All rights reserved.
 *
 *  See http://spp.spolo.org/ for more information.
 *
 *  SanPolo Co.Ltd
 *  http://spp.spolo.org/
 *  Any copyright issues, please contact: copr@spolo.org
 */
 
/*
 * 作用:将数据由obj格式转换成x3d格式
 * 使用方法 :
 * 1. load("/apps/util/resolvex3d.esp"); // 引入resolvex3d.esp
 * 2. GVAR_ResolveX3D.ResolveX3D(x3d_path); // 解析x3d文件
 * 传入参数 : 本地临时目录下的x3d文件地址
 * 返回值:  1. 成功返回 : Success 
 *          2. 没找到x3d文件 : NotFindX3DFile
 * 
 */	
var GVAR_ResolveX3D ;
 
(function()
{
	if(!GVAR_ResolveX3D)
	{
		GVAR_ResolveX3D = {};
		
		var factory , builder , ocmxml ; 
		var JCR_TYPE="sling:Folder";
		var RES_TYPE="model";
		var RES_TYPE_KEY="sling:resourceType";
		var TAG_INVALID = 0;
		var TAG_IMAGETEXTURE = 1;
		var JCR_EntryPart = currentNode.name ; 
		var docBuilderFactory = new Packages.javax.xml.parsers.DocumentBuilderFactory.newInstance();
		var nameIdentify = 0;
		
		// 删除当前节点下的所有子节点
		function clear_nodes(x3dnode)
		{
			var childs = x3dnode.getNodes();
			
			for(var child in childs)
			{
				x3dnode.getNode(child).remove();
			}
				
			x3dnode.save();
		}
		
		//处理一级材质的图片的url
		function proc_url_attribute(url_value)
		{
			//按照X3D规范处理url_value的值。
			var parts = url_value.split("\"");
			
			//最终结果路径。
			var resultPathList = new Packages.java.util.ArrayList() ;  
			
			for(var p in  parts)
			{
				p = new Packages.java.lang.String(p) ; 
				
				p = p.trim();
				
				if(p.length() > 0)
				{
					//这是一个字符串。
					if(p.charAt(0) == '/' || (p.length() > 1 && p.charAt(1) == ':') )
					{
						//如果是本地全路径,忽略它.
						continue;
					}
					if(JCR_EntryPart != null && p.indexOf(':') < 0)
					{
						//p是相对路径
						p = JCR_EntryPart + "/" + p;
						
						p = p.toLowerCase();
					}
					resultPathList.add(p);
				}
			}
			var ret = url_value;
			
			if(resultPathList.size() == 1)
			{
				ret = resultPathList.get(0);
					
			}else if(resultPathList.size() > 1)
			{
				var	builder = new Packages.java.lang.StringBuilder();
				
				for(var i = 0; i < resultPathList.size(); i++)
				{
					if(builder.length() > 0)
					{
						builder.append(" ");
					}
					builder.append("\"");
					
					builder.append(resultPathList.get(i));
					
					builder.append("\"");
				}
				
				if(builder.length() > 0)
					ret = builder.toString();
			}
			
			return ret;
		}

		// 添加子节点
		function append_jcrnode_from_xmlnode(jcrparent , xmlele)
		{
			var childName = null;
			
			var def = xmlele.getAttribute("DEF");
			
			var id = xmlele.getAttribute("id");
			
			if(def.length() != 0)
			{
				childName = def;
				
			}else if(id.length() != 0)
			{
				childName = id;
				
			}else
			{
				childName = "uname" + nameIdentify++;
					
			}
			
			//jcr child
			var jc = jcrparent.addNode(childName,JCR_TYPE);
			
			jc.setProperty(RES_TYPE_KEY,RES_TYPE);
			
			var tagName = xmlele.getTagName();
			
			jc.setProperty( "sp:Tag", tagName);
			
			var props = xmlele.getAttributes();
			
			var Hacker_Tag_type = 0;
			
			//这里根据tagname做一些参数调整，例如Texture的路径。注意，路径是从父窗口开算的。
			if(tagName.toLowerCase().equals("imagetexture"))
			{
				Hacker_Tag_type = TAG_IMAGETEXTURE;
			}
				
			for(var idx = 0; idx < props.getLength() ; idx++)
			{
				var prop = props.item(idx);
				
				if(prop.getNodeType() == 2 )
				{
					//是一个属性节点。
					var attr = prop ; 
					
					if(attr.isId() || attr.getName().toLowerCase().equals("def"))
					{
						continue;
					}
					var attrName = attr.getName();
					
					var attrValue = attr.getValue();
					
					switch(Hacker_Tag_type)
					{
						case TAG_IMAGETEXTURE:
							if(attrName.toLowerCase().equals("url"))
							{
								attrValue = proc_url_attribute(attrValue);
							}
						break;
					}
					
					jc.setProperty(attrName, attrValue);
				}
			}
			
			//属性设置完毕，开始递归xmlele.
			var xml_childs = xmlele.getChildNodes();
			
			for(var idx = 0; idx < xml_childs.getLength(); idx++)
			{
				var tmpn = xml_childs.item(idx);
				
				if(tmpn.hasAttributes())
				{
					append_jcrnode_from_xmlnode(jc,tmpn);
				}
			}	
		}		
		
		//解析x3d文件,创建jcr节点
		function parse_xml_stream(x3dnode , x3dcontent)
		{
			try
			{
				docBuilderFactory.setIgnoringComments(true);
				
				docBuilderFactory.setNamespaceAware(false);
				
				docBuilderFactory.setValidating(false);
				
				docBuilderFactory.setXIncludeAware(false);
				
				var docBuilder = docBuilderFactory.newDocumentBuilder();
				
				var doc = docBuilder.parse(x3dcontent);
				
				doc.getDocumentElement().normalize();

				var nList = doc.getElementsByTagName("Scene");
				
				nameIdentify = 0;
				
				for(var idx = 0; idx < nList.getLength(); idx++) {
					
					var xn = nList.item(idx);

					var scene_Childs = xn.getChildNodes();
					
					for(var secondi = 0; secondi < scene_Childs.getLength(); secondi++)
					{
						var tmpn = scene_Childs.item(secondi) ;
						
						if(tmpn.hasAttributes())
						{	
							append_jcrnode_from_xmlnode(x3dnode,tmpn);
						}
					}
				}
				
				x3dnode.save();
				
			}catch(e)
			{
				out.write("\n  error");
				out.write(e) ; 
			}
		}

		//请求 UploadX3D Servlet,上传x3d文件
		function upload_x3d_file(x3dNode,x3d_path)
		{
			try
			{
				var x3d_file = new Packages.java.io.File(x3d_path);
				
				if(x3d_file.exists())
		        {
					parse_xml_stream(x3dNode,x3d_file);	
				}
				else
				{
					out.write("NotFindX3DFile");
				}
			}
			catch(e)
			{
			   out.write(e);	
			}
		}

		//解析本地x3d文件
		GVAR_ResolveX3D.ResolveX3D = function(x3d_path)
		{
			//判断当前模型节点有没有x3d子节点,没有创建之.
			var x3dNode ; 
			try{
				x3dNode = currentNode.getNode("x3d");
			}catch(e){
				x3dNode = currentNode.addNode("x3d");
				
				currentNode.save();
			}
			
			//清空jcr_path下所有的节点
			clear_nodes(x3dNode) ; 
		
			//解析x3d文件,在modelxxx/x3d节点下添加节点
			upload_x3d_file(x3dNode,x3d_path); 
			
			currentNode.save() ; 
			
			out.write("Success");
		}
		
	}
}());

%>