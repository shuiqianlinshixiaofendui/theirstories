<%
/* 
 *  This file is part of the SPP(Superpolo Platform).
 *  Copyright (C) by SanPolo Co.Ltd.
 *  All rights reserved.
 *
 *  See http://spp.spolo.org/ for more information.
 *
 *  SanPolo Co.Ltd
 *  http://spp.spolo.org/
 *  Any copyright issues, please contact: copr@spolo.org
 */
 
 
/*  读取tdata中的数据根据其中的数据在ocs文件模板中添加相应信息以及相关设置，
	材质对应关系等，
	最终产生ocs文件以供渲染使用
*/

//加载node处理库
	load("/apps/util/node.esp");

//加载octane模板
	load("/apps/renderjob/region/tm_octane.esp");
	

//获取并设置所需全局变量
	var GVAR_CurrentNode;
	var GVAR_Session;
	var GVAR_WorkSpace;
	var GVAR_RootNode;
	var GVAR_COUNT;

	GVAR_CurrentNode = currentNode;
	GVAR_Session = currentNode.getSession();
	GVAR_WorkSpace = GVAR_Session.getWorkspace();
	GVAR_RootNode = GVAR_Session.getRootNode();
	GVAR_COUNT = 0;
	GVAR_Path = "C:/tmp";


//递归复制节点
	function copyNodes(srcAbsPath, desAbsPath)
	{   //copy every subnodes of srcNode to desNode
		srcNode = GVAR_RootNode.getNode(srcAbsPath.substring(1,srcAbsPath.length));
		childList = srcNode.getNodes();
		for(var i in childList)
		{
			child = childList[i];
			childName = child.getName();
			childPath = child.getPath();
			GVAR_WorkSpace.copy(childPath, desAbsPath + '/' + childName);
		}
	}
 
 
 //解析当前场景中所有的材质，存储材质名称以及资源对应路径
	function parsemat(tddata,matmap)
	{//parse the mat of tddata and write the mat's properties to Array matmap
		if(tddata.hasNodes())
		{
			for(var nodeindex in tddata.getNodes())
			{
				var inode = tddata.getNodes()[nodeindex];
				if((inode["sp:Tag"] == "Material") && (inode["USE"] == null))
				{
					var matpath = inode.getPath();
					matmap[inode.getName()] = matpath.substr(1);
				}
				if(inode.hasNodes())
				{
					parsemat(inode,matmap);
				}
			}
		}
	} 


	function dump_ocs()
	{
		var framenode = currentNode.getParent();
		var tddatanode = framenode["tddata"];
		var renderdatanode = framenode["renderdata"];

		
	//遍历tddata节点将x3d中材质与ocm对应关系存入数组中
		
		var matmap = [];
		parsemat(tddatanode,matmap);


		
		//打开模板ocs文件并解析
		var ocs_instr = new Packages.org.xml.sax.InputSource();
		ocs_instr.setCharacterStream(new Packages.java.io.StringReader(ocs_str));

		
		var factory = new Packages.javax.xml.parsers.DocumentBuilderFactory.newInstance();
		var builder = factory.newDocumentBuilder();
		var ocsxml = builder.parse(ocs_instr);
		
		
		//获取OCS_1_0_23_Scene节点，即ocs的根节点
		var scenert = ocsxml.getElementsByTagName("OCS_1_0_30_Scene");
		
		//获取embeddedimages节点，供以后添加图片数据
		var embeddedimagesnode = scenert.item(0).getElementsByTagName("embeddedimages").item(0);
		
		//embeddedimages中已有image
		var em_images = [];
		
		var em_floatimages = [];
		
		
		if(scenert.item(0).getNodeName() == "OCS_1_0_30_Scene" )
		{
			
			//获取所有Node节点
			var snode = scenert.item(0).getElementsByTagName("Node");
			
			//通过第一个node节点获取其childgraph子节点
			var childgraph = snode.item(0).getElementsByTagName("childgraph");
			
			//获取childgraph的NodeGraph子节点
			var NodeGraph = childgraph.item(0).getElementsByTagName("NodeGraph");
			
			//获取NodeGraph的nodes子节点以供之后获取摄像机属性相关子节点
			var NodeGraphnodes = NodeGraph.item(0).getElementsByTagName("nodes").item(0);
			
			var cameranode;
			
			//获取前端传递过来的摄像机中心点坐标
			
			var campos = request.getRequestParameter("position");
			if(campos == null)
			{
				campos = "0_0_10";
			}
			
			//获取前端传递过来的摄像机目标点坐标
			var camtar = request.getRequestParameter("centerOfRotation");
			if(camtar == null)
			{
				camtar = "0_0_0";
			}
			
			
			//获取前端传递过来的摄像机自身旋转信息
			var camup = request.getRequestParameter("upOfRotation");
			if(camup == null)
			{
				camup = "0_1_0";
			}
			
			
			//将获取参数转换为字符串
			campos = new String(campos);
			camtar = new String(camtar);
			camup = new String(camup);
			
			
		//解析并处理摄像机相关属性
			
			//解析并处理摄像机中心点坐标
			var pos = [];
			var itp = 0;
			var ip = 0;
			for(var i = 0; i < campos.length; i++)
			{
				if(campos[i] == "_")
				{
					pos[ip] = campos.substr(itp,i - itp);
					itp = parseInt(i) + 1;
					ip++;
				}
			}
			pos[ip] = campos.substr(itp,campos.length - itp);
			
			for(var i in pos)
			{
				pos[i] = parseFloat(pos[i]);
			}
			
			pos[0] = -pos[0];
			pos[2] = -pos[2];
			
			//解析并处理摄像机目标点坐标
			var tar = [];
			var itt = 0;
			var it = 0;
			for(var i = 0; i < camtar.length; i++)
			{
				if(camtar[i] == "_")
				{
					tar[it] = camtar.substr(itt,i - itt);
					itt = parseInt(i) + 1;
					it++;
				}
			}
			tar[it] = camtar.substr(itt,camtar.length - itt);
			
			for(var i in tar)
			{
				tar[i] = parseFloat(tar[i]);
			}
			
			tar[0] = -tar[0];
			tar[2] = -tar[2];
			
			
			//解析并处理摄像机旋转信息
			var cameraup = [];
			var itu = 0;
			var iu = 0;
			for(var i = 0; i < camup.length; i++)
			{
				if(camup[i] == "_")
				{
					cameraup[iu] = camup.substr(itu,i - itu);
					itu = parseInt(i) + 1;
					iu++;
				}
			}
			cameraup[iu] = camup.substr(itu,camup.length - itu);
			
			for(var i in cameraup)
			{
				cameraup[i] = parseFloat(cameraup[i]);
			}
			
			cameraup[0] = -cameraup[0];
			cameraup[2] = -cameraup[2];
			
			
			//获取并处理输出图片尺寸
			var size = request.getParameter("size");
			
			if(size == null)
			{
				size = "800_600";
			}

			size = new String(size);
				
			size = size.replace(/_/g , " ");
			
			
			
			
			//遍历nodes节点的所有子节点以设置摄像机相关属性
			for(var i = 0; i < NodeGraphnodes.getElementsByTagName("Node").length; i++)
			{
				var inode = NodeGraphnodes.getElementsByTagName("Node").item(i);
				var namenode = inode.getElementsByTagName("name").item(0);
				if(namenode != null)
				{
					var name = namenode.getChildNodes().item(0).getNodeValue();
					if(name == "Preview Configuration")
					{
						//在Preview Configuration子节点中获取摄像机属性相关子节点
						
						var pvcnodes = inode.getElementsByTagName("Node");
						for(var ip = 0; ip < pvcnodes.length; ip++)
						{
							var ipnode = pvcnodes.item(ip);
							
							
							//设置摄像机位置信息
							if(ipnode.getElementsByTagName("name").item(0).getChildNodes().item(0).getNodeValue() == "Mesh Preview Camera")
							{
								//在Mesh Preview Camera子节点中遍历并查找摄像机位置相关属性
								
								var nodepins = ipnode.getElementsByTagName("NodePin");
								
								for(var inp = 0; inp < nodepins.length; inp++)
								{	
									var inpnode = nodepins.item(inp);
									var inpname = inpnode.getElementsByTagName("typename").item(0).getChildNodes().item(0).getNodeValue();;
									
									//设置摄像机中心点坐标
									if(inpname == "pos")
									{
										inpnode.getElementsByTagName("valuexyz").item(0).getChildNodes().item(0).setNodeValue(pos[0] + " " + pos[1] + " " + pos[2]);
									}
									
									//设置摄像机目标点坐标
									if(inpname == "target")
									{
										inpnode.getElementsByTagName("valuexyz").item(0).getChildNodes().item(0).setNodeValue(tar[0] + " " + tar[1] + " " + tar[2]);
									}
									
									//设置摄像机自身旋转
									if(inpname == "up")
									{
										inpnode.getElementsByTagName("valuexyz").item(0).getChildNodes().item(0).setNodeValue(cameraup[0] + " " + cameraup[1] + " " + cameraup[2]);
									}
								}
							}
							
							
							//设置输出图片尺寸
							if(ipnode.getElementsByTagName("name").item(0).getChildNodes().item(0).getNodeValue() == "Mesh Preview Resolution")
							{
								ipnode.getElementsByTagName("valuexy").item(0).getChildNodes().item(0).setNodeValue(size);
							}
						}
					}
					
					
				}
			}
			
			

			
	//添加模型节点
			
			//获取模型节点模板并解析
			var mesh_instr = new Packages.org.xml.sax.InputSource();
			mesh_instr.setCharacterStream(new Packages.java.io.StringReader(mesh_str));
			
			var meshtxml = builder.parse(mesh_instr);
			
			
			//获取模型节点中的Node
			var ocsmeshnode = meshtxml.getElementsByTagName("Node").item(0);
			
			
			//获取模型名称节点
			var meshnamenode = ocsmeshnode.getElementsByTagName("name").item(0);
			
			//设置模型节点名称
			meshnamenode.getChildNodes().item(0).setNodeValue("rendermesh.obj");
			
			
			//获取链接obj文件节点
			var linkedfilenode = ocsmeshnode.getElementsByTagName("linkedfilename").item(0);
			
			
			//设置链接obj文件
			linkedfilenode.getChildNodes().item(0).setNodeValue("rendermesh.obj");
			
			
			//获取模型节点中inputnodepins,即期材质输入节点
			var inputnodepins = ocsmeshnode.getElementsByTagName("inputnodepins").item(0);
			
			var matindex = 0;
			
			//根据之前解析的材质信息创建模型节点上所有的材质输入节点
			
			for(var imat in matmap)
			{
				var Nodepin = meshtxml.createElement("NodePin");
				
				var typename = meshtxml.createElement("typename");
				typename.appendChild(meshtxml.createTextNode(imat));
				Nodepin.appendChild(typename);
				
				var id = meshtxml.createElement("id");
				id.appendChild(meshtxml.createTextNode(matindex));
				matindex = matindex + 1;
				Nodepin.appendChild(id);
				
				
				var hasinternalnodegraph = meshtxml.createElement("hasinternalnodegraph")
				hasinternalnodegraph.appendChild(meshtxml.createTextNode("false"));
				Nodepin.appendChild(hasinternalnodegraph);
				
				inputnodepins.appendChild(Nodepin);
			}
			
			
			var tmpnode = ocsxml.importNode(ocsmeshnode,true);
			NodeGraphnodes.appendChild(tmpnode);

			
			//根据之前解析的材质信息，通过其中路径信息将所有材质节点都复制到ocs文件中并分配id，id号从4开始
			matindex = 3;
			for(var imat in matmap)
				{
					matindex++;
					
				//获取材质ocm文件并解析
					//根据材质节点中的引用信息获得以及材质ocm文件
					var tmpmatnode = GVAR_RootNode.getNode(matmap[imat]);
					
					var refL1Matpath = tmpmatnode["sp:refL1Material"];
					if(refL1Matpath == null || refL1Matpath == undefined)
					{
						out.write(tmpmatnode.path + "has a error of refL1Material\n!");
						continue;
					}
					if(refL1Matpath[0] == "/")
					{
						refL1Matpath = refL1Matpath.substr(1);
					}
					var l1matdata = GVAR_RootNode.getNode(refL1Matpath);
					
					var hasdiff = tmpmatnode["sp:hasdiffuse"];
					if(hasdiff != "false")
					{
						
						
					//将所需图片数据写入renderdata节点下
						//根据L1Material节点获取diffuse节点
						var diffusenode = l1matdata.getParent();
						while(1)
						{
							if(diffusenode["sling:resourceType"] == "diffuse")
							{
								break;
							}
							
							diffusenode = diffusenode.getParent();
						}
						
						//
						var diffuseName = "";
						var bumpName = "";
						var normalName = "";
						var opacityName = "";
						var modelName = "";
						//遍历diffuse节点下的所有节点将mask数据写入renderdata节点下
						for(var i in diffusenode)
						{
							
							var imnode = diffusenode[i];
							
							
							if(imnode["sp:isauto"] == "true")
							{
								diffuseName = imnode["diffuseName"];
								bumpName = imnode["bumpName"];
								normalName = imnode["normal"];
								opacityName = imnode["opacityName"];
								modelName = imnode["modelName"];
								
								continue;
							}
							
							if(imnode["sling:resourceType"] == "mask")
							{
								if(renderdatanode[imnode["modelName"] + "_" + imnode["diffuseName"] + "_" + imnode["name"]] == null)	
								{
									var fileNode = renderdatanode.addNode(imnode["modelName"] + "_" + imnode["diffuseName"] + "_" + imnode["name"], "nt:file");
									var resNode = fileNode.addNode("jcr:content", "nt:resource");
									resNode.setProperty("jcr:data", imnode["maskfile"]["jcr:content"]["jcr:data"]);
								}
								
								diffuseName = imnode["diffuseName"];
								modelName = imnode["modelName"];
							}
						}
						
						//将diffuse节点下的diffuse texture数据写入renderdata节点下
						if(renderdatanode[modelName + "_" + diffuseName] == null)
						{
							if(diffusenode["diffusefile"] != undefined)
							{
								var fileNode = renderdatanode.addNode(modelName + "_" + diffuseName, "nt:file");
								var resNode = fileNode.addNode("jcr:content", "nt:resource");
								resNode.setProperty("jcr:data", diffusenode["diffusefile"]["jcr:content"]["jcr:data"]);
								renderdatanode.save();
							}
						}
						
						//将diffuse节点下的bump texture数据写入renderdata节点下
						if(renderdatanode[modelName + "_" + bumpName] == null)
						{
							if(diffusenode["bumpfile"] != undefined)
							{
								var fileNode = renderdatanode.addNode(modelName + "_" + bumpName, "nt:file");
								var resNode = fileNode.addNode("jcr:content", "nt:resource");
								resNode.setProperty("jcr:data", diffusenode["bumpfile"]["jcr:content"]["jcr:data"]);
								renderdatanode.save();
							}
						}
						
						
						//将diffuse节点下的normal texture数据写入renderdata节点下
						if(renderdatanode[modelName + "_" + normalName] == null)
						{
							if(diffusenode["normalfile"] != undefined)
							{
								var fileNode = renderdatanode.addNode(modelName + "_" + normalName, "nt:file");
								var resNode = fileNode.addNode("jcr:content", "nt:resource");
								resNode.setProperty("jcr:data", diffusenode["normalfile"]["jcr:content"]["jcr:data"]);
								renderdatanode.save();
							}
						}
						
						//将diffuse节点下的opacity texture数据写入renderdata节点下
						if(renderdatanode[modelName + "_" + opacityName] == null)
						{
							if(diffusenode["opacityfile"] != undefined)
							{
								var fileNode = renderdatanode.addNode(modelName + "_" + opacityName, "nt:file");
								var resNode = fileNode.addNode("jcr:content", "nt:resource");
								resNode.setProperty("jcr:data", diffusenode["opacityfile"]["jcr:content"]["jcr:data"]);
								renderdatanode.save();
							}
						}
					}

					
				//解析ocm文件
					var tmpmatfile = l1matdata["jcr:content"]["jcr:data"];
					var tmpmatxml = builder.parse(tmpmatfile);
					
					//获取材质ocm文件中OCS_1_0_23_Macro节点，即其根节点
					var tmacronode = tmpmatxml.getDocumentElement();;
					
					
					//获取embeddedimages子节点，以获取其图片数据
					var tembeddedimages = tmacronode.getElementsByTagName("embeddedimages").item(0);
					
					//若embeddedimages不为空，则将其中数据都复制到ocs文件的embeddedimages节点中
					if(tembeddedimages != null)
					{
						var timagenodelist = tembeddedimages.getElementsByTagName("image");
						
						for(var img = 0; img < timagenodelist.length; img++)
						{
							var timgnode = timagenodelist.item(img);
							
							//当前image name
							var imagename = timgnode.getElementsByTagName("name").item(0).getChildNodes().item(0).getNodeValue();
							var imagename = new String(imagename);
								
								
							if(em_images.indexOf(imagename.toString()) == -1)
							{
								em_images.push(imagename.toString());
								var tmpnode = ocsxml.importNode(timgnode,true);
								embeddedimagesnode.appendChild(tmpnode);
							}
						}
						
						
						
						var timagenodelist = tembeddedimages.getElementsByTagName("floatimage");
						
						for(var img = 0; img < timagenodelist.length; img++)
						{
							var timgnode = timagenodelist.item(img);
							
							//当前image name
							var imagename = timgnode.getElementsByTagName("name").item(0).getChildNodes().item(0).getNodeValue();
							var imagename = new String(imagename);
								
								
							if(em_floatimages.indexOf(imagename.toString()) == -1)
							{
								em_floatimages.push(imagename.toString());
								var tmpnode = ocsxml.importNode(timgnode,true);
								embeddedimagesnode.appendChild(tmpnode);
							}
						}
										
					}
					
					//获取材质ocm文件的Node节点
					var tmpmatnode = tmacronode.getElementsByTagName("Node").item(0);
					
					//设置材质节点中材质名称属性
					tmpmatnode.getElementsByTagName("name").item(0).getChildNodes().item(0).setNodeValue(imat);// = imat;
					
					//获取材质id节点并设置id号
					if(tmpmatnode.getElementsByTagName("typename").item(0).getChildNodes().item(0).getNodeValue() == "material macro")
					{
						tmpmatnode.getElementsByTagName("id").item(0).getChildNodes().item(0).setNodeValue(matindex);
					}
					
					//将此材质节点添加到ocs文件中
					var tmpnode = ocsxml.importNode(tmpmatnode,true);
					NodeGraphnodes.appendChild(tmpnode);
			}
			
			
		//创建octane材质与obj中材质的对应关系
			
			
			//获取存储模型材质对应的nodepinconnections节点
			var nodepinconnections = ocsxml.getElementsByTagName("nodepinconnections").item(ocsxml.getElementsByTagName("nodepinconnections").length - 1);
			
			matindex = 0;
			
			//根据之前解析的材质信息来做模型节点中材质输出节点与材质节点中输出节点的对应关系
			for(var imat in matmap)
			{
				//创建一个nodepinconnection节点，即可以存储模型中材质输入与材质节点中输出节点的一组对应关系
				var nodepinconnection = ocsxml.createElement("nodepinconnection");
				
				
				//创建sourceid节点，并设置其对应材质的id并将其添加到nodepinconnection节点之下
				var sourceid = ocsxml.createElement("sourceid");
				sourceid.appendChild(ocsxml.createTextNode(matindex + 4));
				nodepinconnection.appendChild(sourceid);
				
				//创建sourcepinid节点，并设置其对应材质的中的pinid并将其添加到nodepinconnection节点之下
				var sourcepinid = ocsxml.createElement("sourcepinid");
				sourcepinid.appendChild(ocsxml.createTextNode("0"));
				nodepinconnection.appendChild(sourcepinid);
				
				
				//创建destid节点，并设置其对应模型中输入节点的id，将其添加到nodepinconnection节点之下
				var destid = ocsxml.createElement("destid");
				destid.appendChild(ocsxml.createTextNode("3"));
				nodepinconnection.appendChild(destid);
				
				//创建destpinid节点，并设置其对应模型中输入节点中的pinid，将其添加到nodepinconnection节点之下
				destpinid = ocsxml.createElement("destpinid")
				destpinid.appendChild(ocsxml.createTextNode(matindex));
				nodepinconnection.appendChild(destpinid);
				matindex = matindex + 1;
				
				
				//将nodepinconnection节点添加到nodepinconnections节点之下
				nodepinconnections.appendChild(nodepinconnection)
			
			
			}
		}
		
		
		
		//将ocs文件直接存入jcr中
			//创建xml transformer
			var transfactory = new Packages.javax.xml.transform.TransformerFactory.newInstance();
			var transformer = transfactory.newTransformer();
			
			//创建stringWriter与xml StreamResult
			var stringWriter = new Packages.java.io.StringWriter();
			var result = new Packages.javax.xml.transform.stream.StreamResult(stringWriter);
			
			//将xml数据写入result中
			transformer.transform(new Packages.javax.xml.transform.dom.DOMSource(ocsxml), result);
			
			
			var ocsNode = currentNode.addNode("render.ocs", "nt:file");
			var ocsContent = ocsNode.addNode("jcr:content", "nt:resource");
			ocsContent.setProperty("jcr:mimeType","octane/ocs");
			
			//将数据写入ocm节点之下
			ocsContent.setProperty("jcr:data", stringWriter.getBuffer());
				
			GVAR_Session.save();
		
	}
	
	dump_ocs();
%>
