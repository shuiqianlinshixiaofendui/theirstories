<%
/* 
 *  This file is part of the SPP(Superpolo Platform).
 *  Copyright (C) by SanPolo Co.Ltd.
 *  All rights reserved.
 *
 *  See http://spp.spolo.org/ for more information.
 *
 *  SanPolo Co.Ltd
 *  http://spp.spolo.org/
 *  Any copyright issues, please contact: copr@spolo.org
 */
 
 
/*本库拓展了对node的维护。支持如下名称空间nodeUtils,支持如下方法:

深度优先遍历，VisitNodeFunc的原型为VisitNodeFunc(node,level)。如果继续递归其孩子，返回true或者后期处理函数。否则返回false。
depthFirstTraversal(jcrNode,VisitNodeFunc);
广度优先遍历，含义同上。
widthFirstTraversal(jcrNode,VisitNodeFunc);


使用方法: <code>
	load("/apps/util/node.esp");
	//这里可以调用nodeUtils名称空间中的方法、属性。
	</code>
*/

var nodeUtils;

//只执行一次。
if(!nodeUtils)
{
	(function(){
		nodeUtils = {};
		
		//深度优先遍历一个节点开始的子节点，不包含node自身。
		function depthFirstTraversal(node,VisitNodeFunc,level)
		{
			if(typeof(level) == "undefined")
				level = 0;
			else
				level++;
			var childIt = node.getNodes();
			for(var i = 0; i < childIt.length; i++)
			{
				child = childIt[i];
				var postProc = VisitNodeFunc(child,level);
				if(postProc)
				{
					depthFirstTraversal(child,VisitNodeFunc,level);
					if(typeof(postProc) == "function")
						postProc();
				}
			}
		};
		
		//广度优先遍历一个节点开始的子节点，不包含node自身。
		function widthFirstTraversal(node,VisitNodeFunc,level)
		{
			if(typeof(level) == "undefined")
				level = 0;
			else
				level++;
			var visitNodeArray = [];
			var visitNodePostProc = [];
			var childIt = node.getNodes();
			for(var i = 0; i < childIt.length; i++)
			{
				child = childIt[i];
				var postProc = VisitNodeFunc(child,level);
				if(postProc)
				{
					visitNodeArray.push(child);
					visitNodePostProc.push(postProc);
				}
			}
			
			for(var i = 0; i < visitNodeArray.length; i++)
			{
				widthFirstTraversal(visitNodeArray[i],VisitNodeFunc,level);
				if(typeof(visitNodePostProc[i]) == "function")
				{
					visitNodePostProc[i]();
				}
			}
		}

		function getNodeFromMD5(root, md5) {
			var md5array = md5.toArray();
				arrayLength = md5array.length,
				flag = null,
				parentNode = null,
				nodePath = null;

			for(var i = 1; i != arrayLength + 1; i++) {
				nodePath = md5array.slice(0, i).join("/");
				if(!root.hasNode(nodePath)) {
					flag = i - 1;
					break;
				}
			}

			nodePath = md5array.slice(0, flag+1).join("/");
			if(flag >=0) {
				if(flag == 0) {
					parentNode = root;
				} else {
					parentNode = root.getNode(nodePath);
				}
				for(var j = flag; j != arrayLength; j++) {
					var subNode = parentNode.addNode(md5array[j]);
					parentNode = subNode;
				}
				return parentNode;				
			} else {
				return root.getNode(md5array.join("/"));
			}
		}

		// function getNodeFromMD5(root, md5, create) {
		// 	out.println(md5.toHexString())
		// 	var md5arry = md5.toArray(),
		// 		nodePath = md5arry.join("/");

		// 	if(root.hasNode(nodePath)) {
		// 		out.println("Find: " + nodePath);
		// 		return root.getNode(nodePath);
		// 	} else {
		// 		//If we can't get node from given md5
		// 		if(create) {
		// 			// If parameter create is True, then we creeat this
		// 			// series of nodes from given md5 
		// 			var start = -1,
		// 				end = md5arry.length,
		// 				mid = Math.ceil((start+end) / 2),
		// 				parentNode = null;

		// 			while(end >= start && end != -1) {
		// 				out.println("Start: " + start, ", End: " + end, ", Mid: " + mid);
		// 				nodePath = md5arry.slice(0, mid+1).join("/");
		// 				if(!root.hasNode(nodePath)) {
		// 					out.println("Not has: " + nodePath);
		// 					end = mid - 1;
		// 				} else {
		// 					out.println("Has: " + nodePath);
		// 					start = mid + 1;
		// 				}
		// 				mid = Math.ceil((start+end) / 2);
		// 			}
		// 			// out.println("Start: " + start, ", End: " + end, ", Mid: " + mid);
		// 			if(mid == -1) mid = 0;
		// 			nodePath = md5arry.slice(0, mid).join("/");
		// 			if(nodePath) {
		// 				parentNode = root.getNode(nodePath);
		// 			} else {
		// 				parentNode = root;
		// 			}
		// 			for(var i = mid; i < md5arry.length; i++) {
		// 				// out.println("add: " + md5arry[i])
		// 				var subNode = parentNode.addNode(md5arry[i]);
		// 				parentNode = subNode;
		// 			}
		// 			return parentNode;
		// 		} else {
		// 			return null;
		// 		}
		// 	}
		// }
		
		nodeUtils.depthFirstTraversal = depthFirstTraversal;
		nodeUtils.widthFirstTraversal = widthFirstTraversal;
		nodeUtils.getNodeFromMD5 = getNodeFromMD5;
	}());
}

%>