/** *  This file is part of the spp(Superpolo Platform). *  Copyright (C) by SanPolo Co.Ltd. *  All rights reserved. * *  See http://www.spolo.org/ for more information. * *  SanPolo Co.Ltd *  http://www.spolo.org/ *  Any copyright issues, please contact: copr@spolo.org**//**	摄像机子模块	负责处理摄像机事件：	* 摄像机平移	* 摄像机旋转	* 摄像机缩放*/define("web3d/node/cameraOperate_mrs",["dojo/topic"],function(topic){			var model_axis = new x3dom.fields.SFVec3f(0,0,0); 	var model_click = false;		// 摄像机锁定	var camera_isLocked = false;	// 摄像机动作	var camera_status = 0 ;	var CAMERA_MOVE = 0; 	var CAMERA_ROTATE = 1; 	var CAMERA_SCALE = 2; 		//绕物体变换模式是否锁定	var aroundObj_isLocked = false;			/**		全局变量x3domViewarea,dx,dy,viewpoint,min, max, ok, d, vec	*/ 	var x3domViewarea = null ;	var dx = 0 ;	var dy = 0 ;	var viewpoint = null ;	var min, max, ok, d, vec;		/**		记录旋转变量	*/	var getAxisBool = false; // 是否获取旋转轴，当发生平移或者缩放时，重新获取旋转轴false,否则为true。	var sy_axis = new x3dom.fields.SFVec3f(0,0,10); // 初始旋转轴 	var scaleBool = false ; // 记录当前是否开始缩放	var start_scale_matrix ; // 记录缩放前的摄像机矩阵	var end_start_vector = new x3dom.fields.SFVec3f(0,0,0); // 记录缩放后，摄像机的向量差	var axis = new x3dom.fields.SFVec3f(0,0,10);		var tpAxis = new x3dom.fields.SFVec3f(0,0,0);		function calculateAxis(){		/**			在旋转之前，首先判断摄像机是在正向缩放了，还是逆向缩放了。			如果正向缩放，摄像机前面一点将向后平移			如果向后缩放，摄像机前面一点将向前平移		*/				var viewMatrix = x3domViewarea.getViewMatrix();		var axis_view = x3dom.fields.SFMatrix4f.translation(axis).mult(viewMatrix);		var axis_view_world = axis_view.inverse();		var avw_e3 = axis_view_world.e3();		return avw_e3;	}		/**		处理camera_move		autoCreate : copy x3dom 源代码	*/		function cameraMove(){			if(scaleBool){			cameraRotate();		}		tpAxis = calculateAxis();						model_click = false;				getAxisBool = false;		scaleBool = false;			if (x3domViewarea._scene._lastMin && x3domViewarea._scene._lastMax)		{			d = (x3domViewarea._scene._lastMax.subtract(x3domViewarea._scene._lastMin)).length();			d = (d < x3dom.fields.Eps) ? 1 : d;		}		else		{			min = x3dom.fields.SFVec3f.MAX();			max = x3dom.fields.SFVec3f.MIN();			ok = x3domViewarea._scene.getVolume(min, max, true);			if (ok) {				x3domViewarea._scene._lastMin = min;				x3domViewarea._scene._lastMax = max;			}			d = ok ? (max.subtract(min)).length() : 10;			d = (d < x3dom.fields.Eps) ? 1 : d;		}		vec = new x3dom.fields.SFVec3f(d*dx/x3domViewarea._width, d*(-dy)/x3domViewarea._height, 0);		x3domViewarea._movement = x3domViewarea._movement.add(vec);		//TODO; move real distance along viewing plane		x3domViewarea._transMat = viewpoint.getViewMatrix().inverse().		mult(x3dom.fields.SFMatrix4f.translation(x3domViewarea._movement)).		mult(viewpoint.getViewMatrix());	}	/**		处理camera_rotate,参考帖子号#918	*/	function cameraRotate(){				scaleBool = false ;				var alpha = (dy * 2 * Math.PI) / x3domViewarea._width;		var beta = (dx * 2 * Math.PI) / x3domViewarea._height;		var mat = x3domViewarea.getViewMatrix();		var mx = x3dom.fields.SFMatrix4f.rotationX(alpha);		var my = x3dom.fields.SFMatrix4f.rotationY(beta);		var center = viewpoint.getCenterOfRotation();		mat.setTranslate(new x3dom.fields.SFVec3f(0,0,0));				/**			sy_axis 是旋转轴,一下操作为获得旋转轴			在旋转时，只获得一次旋转轴即可，当发生了平移或者旋转时，在重新获得旋转轴即可						获取摄像机旋转轴:			* 首先 创建一个旋转轴 var axis = new x3dom.fields.SFVec3f(0,0,10);			* 然后 将此点axis平移到摄像机坐标系下				* var viewMatrix = x3domViewarea.getViewMatrix();				* var axis_view = x3dom.fields.SFMatrix4f.translation(axis).mult(viewMatrix);			* 然后 获得将axis_view转化到世界坐标系下，并转化成向量				* var axis_view_world = axis_view.inverse();				* var avw_e3 = axis_view_world.e3();				* sy_axis = avw_e3;		*/			if(!getAxisBool){			if(end_start_vector.z < 0 ){				axis = axis.add(end_start_vector.negate());				end_start_vector = new x3dom.fields.SFVec3f(0,0,0);			}else{				axis = axis.subtract(end_start_vector);				end_start_vector = new x3dom.fields.SFVec3f(0,0,0);			}									sy_axis = calculateAxis();			getAxisBool = true;		}				if(model_click){			sy_axis = model_axis;			tpAxis = sy_axis;		}						x3domViewarea._rotMat = x3domViewarea._rotMat		.mult(x3dom.fields.SFMatrix4f.translation(sy_axis))		.mult(mat.inverse())		.mult(mx)		.mult(mat)		.mult(x3dom.fields.SFMatrix4f.translation(sy_axis.negate()))				.mult(x3dom.fields.SFMatrix4f.translation(sy_axis))				.mult(my)				.mult(x3dom.fields.SFMatrix4f.translation(sy_axis.negate()))							}	/**		处理camera_scale		autoCreate : copy x3dom 源代码	*/	function cameraScale(){			//	tpAxis = calculateAxis();		getAxisBool = false;				/**			在缩放开始时，首先记录一下当前摄像机的矩阵			start_scale_matrix = x3domViewarea.getViewMatrix();		*/		if(!scaleBool){			start_scale_matrix = x3domViewarea.getViewMatrix();			scaleBool = true;		}				/**			获取摄像机和他盯着的点的距离			* 获取当前旋转轴的 -5的位置			* 判断，如果摄像机到盯着的点的位置小于 tp 那么向前进操作终止		*/							var tp = 5-axis.z ;		var cas = start_scale_matrix.multMatrixPnt(tpAxis);		var view_mat_e3 = x3domViewarea.getViewMatrix().inverse().e3();		var csv = view_mat_e3.subtract(cas);				/**			* 获得最开始的位置的单位向量 var start_scale_normalize = start_scale_matrix.inverse().e3().normalize();			* 获得获得当前摄像机单位向量 var view_normalize = view_mat_e3.normalize();			* 如果向量的方向不同，则不让移动		*/		var start_scale_normalize = start_scale_matrix.inverse().e3().normalize();		var view_normalize = view_mat_e3.normalize();		var xVector = start_scale_normalize.x * view_normalize.x;		var yVector = start_scale_normalize.y * view_normalize.y;		var zVector = start_scale_normalize.z * view_normalize.z;		if(xVector < 0 || yVector < 0 || zVector < 0 ){			if(dy > 0 || dx > 0){				return ;			}		}							if (x3domViewarea._scene._lastMin && x3domViewarea._scene._lastMax)		{			d = (x3domViewarea._scene._lastMax.subtract(x3domViewarea._scene._lastMin)).length();			d = (d < x3dom.fields.Eps) ? 1 : d;		}		else		{			min = x3dom.fields.SFVec3f.MAX();			max = x3dom.fields.SFVec3f.MIN();			ok = x3domViewarea._scene.getVolume(min, max, true);			if (ok) {				x3domViewarea._scene._lastMin = min;				x3domViewarea._scene._lastMax = max;			}			d = ok ? (max.subtract(min)).length() : 10;			d = (d < x3dom.fields.Eps) ? 1 : d;		}		vec = new x3dom.fields.SFVec3f(0, 0, d*(dx+dy)/x3domViewarea._height);							x3domViewarea._movement = x3domViewarea._movement.add(vec);				//TODO; move real distance along viewing ray		x3domViewarea._transMat = viewpoint.getViewMatrix().inverse().		mult(x3dom.fields.SFMatrix4f.translation(x3domViewarea._movement)).		mult(viewpoint.getViewMatrix());						/**			在缩放以后			* 首先 获得摄像机缩放后的位置 var end_scale_matrix = x3domViewarea.getViewMatrix();			* 然后 将 start_scale_matrix 转化成向量 var ssm_vector = start_scale_matrix.e3();			* .... 将 end_scale_matrix 转化成向量 var esm_vector = end_scale_matrix.e3();			* .... 计算缩放后 摄像机的向量差 var end_start_vector = esm_vector.subtract(ssm_vector);		*/		var end_scale_matrix = x3domViewarea.getViewMatrix();		var ssm_vector = start_scale_matrix.e3();		var esm_vector = end_scale_matrix.e3();					end_start_vector = esm_vector.subtract(ssm_vector);	}		/**		获取摄像机位置，publish一个消息，并将摄像机位置publish出去	*/	function publicViewPosition(){		if(!aroundObj_isLocked && (Spolo.current_view == Spolo.view_list[0])){			topic.publish("cameraOperate_mrs/cameraPosition",tpAxis);		}	}			/**		当用户点击了reset按钮后，		* 清空摄像机操作中所有变量		* 并且将摄像机设置到初始位置	*/	function resetCameraOperate(){			/**			清空摄像机操作中所有变量		*/		model_axis = new x3dom.fields.SFVec3f(0,0,0); 		model_click = false;		dx = 0 ;		dy = 0 ;			getAxisBool = false; // 是否获取旋转轴，当发生平移或者缩放时，重新获取旋转轴false,否则为true。		sy_axis = new x3dom.fields.SFVec3f(0,0,10); // 初始旋转轴 		scaleBool = false ; // 记录当前是否开始缩放		start_scale_matrix ; // 记录缩放前的摄像机矩阵		end_start_vector = new x3dom.fields.SFVec3f(0,0,0); // 记录缩放后，摄像机的向量差		axis = new x3dom.fields.SFVec3f(0,0,10);		tpAxis = new x3dom.fields.SFVec3f(0,0,0);						/**			并且将摄像机设置到初始位置		*/		if(x3domViewarea){					x3domViewarea.resetView();		} 				publicViewPosition();	}		var cameraOperate_mrs = dojo.declare([],{			constructor : function(x3d){					//接收到工具栏消息绕物体变换模式锁定/解锁			topic.subscribe("toolbar/camera/rotateAtModel",function(isLockedStatus){				if(Spolo.selectedObj){					aroundObj_isLocked = !aroundObj_isLocked;				}								if(!aroundObj_isLocked && (Spolo.current_view == Spolo.view_list[0])){					// 使红点置于原位置					topic.publish("cameraOperate_mrs/cameraPosition",tpAxis);				}			});			//接收到推进放大消息绕物体变换模式锁定			topic.subscribe("shortcut3d/camera/amplify",function(){				aroundObj_isLocked = true;			});			//接收到工具栏消息绕物体变换模式解锁			topic.subscribe("toolbar/camera/reset",function(){				aroundObj_isLocked = false;			});										// 响应选中模型操作摄像机			// topic.subscribe("edit/selected",function(selectedObject){				// if(!camera_isLocked){					// model_axis = Spolo.selectedObj._vf.translation ;					// model_click = true ;				// }							// });					// 响应摄像机锁定事件			topic.subscribe("toolbar/camera/locked",function(isLockedStatus){				camera_isLocked = isLockedStatus;			});									// 响应reset摄像机			topic.subscribe("toolbar/camera/reset",function(resetNum){				// 当reset按钮点击后，将对摄像机所有操作都清空				resetCameraOperate();			});									// 快捷键响应摄像机平移操作			topic.subscribe("shortcut3d/camera/translate",function(){			// console.log(" 摄像机 translate yxl")				if(camera_status != 0){					camera_status = CAMERA_MOVE;				}			});						// 快捷键响应摄像机旋转操作			topic.subscribe("shortcut3d/camera/rotate",function(){				// console.log(" 摄像机 rotate yxl")				if(camera_status != 1){					camera_status = CAMERA_ROTATE;				}			});						// 快捷键响应摄像机缩放操作			topic.subscribe("shortcut3d/camera/farnear",function(){				// console.log(" 摄像机 scale yxl")				if(camera_status != 2){					camera_status = CAMERA_SCALE;				}			});									// 响应摄像机平移操作			topic.subscribe("toolbar/camera/translate",function(){				// console.log(" 摄像机平移 ui")				if(camera_status != 0){					camera_status = CAMERA_MOVE;				}			});						// 响应摄像机旋转操作			topic.subscribe("toolbar/camera/rotate",function(){				// console.log(" 摄像机rotate ui")				if(camera_status != 1){					camera_status = CAMERA_ROTATE;				}			});						// 响应摄像机缩放操作			topic.subscribe("toolbar/camera/farnear",function(){				// console.log(" 摄像机 scale ui")				if(camera_status != 2){					camera_status = CAMERA_SCALE;				}			});						// 响应鼠标抬起，当鼠标抬起后，将x3domViewarea._lastX，x3domViewarea._lastY至-1，所有操作从新开始			topic.subscribe("system/onMouseRelease",function(x,y,buttonState){					if(x3domViewarea){						x3domViewarea._lastX = -1;						x3domViewarea._lastY = -1;					}				});						// 响应onDrag事件			topic.subscribe("system/onDrag",function(x,y,buttonState){				// public viewpoint position				publicViewPosition();				// console.log(" 摄像机 l"+camera_isLocked);				if(!camera_isLocked && !aroundObj_isLocked){					/**						如果是自由视角，onDrag方法这里响应，如果非自由视角，onDrag方法教给其他地方响应					*/						// console.log("Spolo.current_view"+Spolo.current_view +"     Spolo.view_list[0]"+Spolo.view_list[0]+"       buttonState"+buttonState);										if(Spolo.current_view == Spolo.view_list[0]){						/**							当前只兼容鼠标左键操作							包括平移，旋转，缩放都是通过鼠标左键与二维按钮配合实现						*/						if(buttonState == 1){																	/** 								本方法，参考x3dom.Viewarea.onDrag方法中的旋转操作								在本操作中，没有x3domViewarea,需要将x3domViewarea替换成x3d.runtime.canvas.doc._viewarea							*/														x3domViewarea = x3d.runtime.canvas.doc._viewarea;							x3domViewarea.handleMoveEvt(x, y, buttonState);																																		var navi = x3domViewarea._scene.getNavigationInfo();							//console.log(navi);							// if (navi._vf.type[0].length <= 1 || navi._vf.type[0].toLowerCase() === "none") {								// return;							// }							// 当第一次操作时，x3domViewarea._lastX和x3domViewarea._lastY是-1，所以第一次操作需要缓冲一下，第二次onDrag时才开始正式的操作							if( x3domViewarea._lastX == -1 || x3domViewarea._lastY == -1){								x3domViewarea._lastX = x;								x3domViewarea._lastY = y;							}else{								dx = x - x3domViewarea._lastX;								dy = y - x3domViewarea._lastY;																viewpoint = x3domViewarea._scene.getViewpoint();								//if (navi._vf.type[0].toLowerCase() === "examine")								//{									switch (camera_status){										case CAMERA_MOVE :												cameraMove();											break ;										case CAMERA_ROTATE :											cameraRotate();											break ;										case CAMERA_SCALE :											cameraScale();											break ;									}							//	}								// 记录dx,dy,_lastX,_lastY变量								x3domViewarea._dx = dx;								x3domViewarea._dy = dy;								x3domViewarea._lastX = x;								x3domViewarea._lastY = y;							}																	}																						}				}							});							}	});		return cameraOperate_mrs;});